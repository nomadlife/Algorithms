알고리즘에 오신 것을 환영합니다. 오늘, 우리는 노동 조합 발견 문제에 관해 이야기 할 것입니다. 소위 동적 연결 문제를 해결하기위한 일련의 알고리즘. 두 가지 고전적인 알고리즘을 살펴 보겠습니다. 빠른 찾기 및 빠른 조합, 그리고 이러한 알고리즘의 일부 응용 프로그램 및 향상된 기능을 제공합니다. 오늘 강의의 하위 텍스트는 유용한 알고리즘을 개발하기 위해 반복적으로 수행 할 단계를 거쳐 진행되는 것입니다. 첫 번째 단계는 문제를 모델링하는 것입니다. 기본적으로 해결해야 할 문제의 주요 요소는 무엇인지 이해하려고 노력하십시오. 그런 다음 문제를 해결하기위한 알고리즘을 찾아 보겠습니다. 대부분의 경우, 우리가 생각해내는 첫 번째 알고리즘은 충분히 빠르며 아마도 메모리에 적합 할 것이며, 우리는이를 사용하고 사용하지 않을 것입니다. 그러나 다른 많은 경우에는 속도가 충분하지 않거나 메모리가 충분하지 않을 수 있습니다. 그래서, 우리가하는 일은 왜 그 문제를 일으키는지를 다룰 수있는 방법을 찾고, 새로운 알고리즘을 찾고, 우리가 만족할 때까지 반복하는 것입니다. 이것은 알고리즘을 설계하고 분석하는 과학적 접근 방법입니다. 여기서 우리는 수학적 모델을 만들어서 어떤 일이 벌어지고 있는지 이해하고, 그 모델을 검증하고 우리가 일을 개선하는 데 도움이되는 실험을합니다. 먼저, 우리는 동적 연결성 문제에 대해 이야기 할 것입니다.이 모델은 노동 조합 발견을위한 문제의 모델입니다. 그래서 여기에 아이디어가 있습니다. 그들은 N 개의 객체 세트를 가질 것입니다. 그들이 정말로 무엇인지는 중요하지 않습니다. 객체를 모델링하기 위해 0부터 N까지 숫자를 사용합니다. 그리고 나서, 우리는 두 객체 사이의 연결에 대한 아이디어를 가지고 있습니다. 그리고 우리는 두 개의 객체를 연결하라는 명령이있을 것이라고 가정합니다. 주어진 두 객체는 ​​그들 사이에 연결을 제공합니다. 그리고 문제의 핵심 부분은 find 질의이거나 연결된 질의입니다. 단지 묻습니다. 두 객체를 연결하는 경로가 있습니다. 그래서 예를 들어,이 10 개의 객체 집합에서 우리는 이미 4, 3, 3, 8, 6, 5, 9, 4, 2, 1을 연결하는 많은 조합 명령을 수행했습니다. 이제 우리는 연결 쿼리가 0 일 것입니다. 7에 연결되어 있습니까? 음,이 경우 연결이 없으므로 아니오라고 말합니다. 하지만 우리가 8 개가 9 개가 연결되어 있는지 묻는다면? 우리는 예라고 말할 것입니다. 심지어 우리는 8-9 사이의 직접 연결을 가지고 있지 않습니다. 8 세에서 4 세 사이의 경로가 있습니다. 그래서, 그것은 우리의 문제입니다. 공식적으로 주어진 객체 세트에 대해이 두 명령을 지원할 수 있습니다. 자, 우리가 노동 조합을 5, 0으로 더한다고 가정 해 봅시다. 그래서, 그것은 5와 0 사이의 연결을 만듭니다. 7과 2는 7과 2 사이의 연결을 만듭니다. 6 대 1, 6 대 1. 이제 우리가 0을 7에 연결하도록 요청하면 1과 0을 우리는 그렇게 할 수 있습니다. 그리고 그것은 중복 연결입니다. 이제 우리가 0에 연결되면 7로 연결됩니다. 예라고 대답 할 것입니다. 그래서 우리의 문제, 섞어서 조합, 명령 및 연결된 쿼리 및 우리는 공식적으로 많은 수의 개체에 대한 해당 명령을 지원할 수 있어야합니다. 여기에 훨씬 더 큰 예가 있습니다. 그리고 우리는 이것을위한 효율적인 알고리즘이 필요하다는 것을 알 수 있습니다. 우선, 우리는 이것을 위해 컴퓨터가 필요하다는 것을 알 수 있습니다. 인간이 연결되어 있는지 여부를 파악하는 데 꽤 많은 시간이 걸립니다. 이 경우에는 연결이 있습니다. 현재 우리가보고있는 알고리즘은 실제로 두 객체를 연결하는 경로를 제공하지 않습니다. 질문에 대답 할 수있을뿐입니다. 경로가 있습니까? 이 과정의 두 번째 부분에서는 경로를 명시 적으로 찾는 알고리즘을 고려할 것입니다. 그들은 더 많은 일을해야하기 때문에 노동 조합 찾기만큼 효율적이지 않습니다. 자, 이들의 응용, 이러한 알고리즘은 모든 유형의 객체를 포함합니다. 이것들은 디지털 사진에 사용되는데, 객체가 컴퓨터, 소셜 네트워크, 사람들의 위치, 컴퓨터 칩, 회로 요소 또는 프로그램의 변수 이름과 같은 추상적 인 것들, 또는 수학적 세트의 요소, 또는 합성 시스템의 금속성 사이트와 같은 물리적 인 것들. 따라서 모든 다른 유형의 객체가 있지만 프로그래밍을 위해서는 각 객체를 이름과 연결하고 객체의 이름을 0부터 N-1까지의 정수로 지정합니다. 정수를 배열에 인덱스로 사용하고 각 객체와 관련된 정보에 신속하게 액세스 할 수 있기 때문에 프로그램 시작에 매우 편리합니다. 또한 노조 찾기와 관련이없는 많은 세부 사항을 간단하게 나타냅니다. 실제로이 객체 이름에서 정수 0부터 N까지의 매핑을 만들려면 심볼 테이블이나 검색 알고리즘의 적용을 찾아야합니다.이 알고리즘은 나중에이 코스 알고리즘에서 공부할 것 중 하나이며 그 문제를 해결하기위한 데이터 구조. 이제, 연결들, 우리는 이러한 연결들이 만족해야만하는 몇 가지 추상적 속성들을 필요로합니다. 그리고 그들은 모두 매우 자연스럽고 직관적입니다.

그래서 우리는 그것이 연결되어 있다고 가정합니다. 즉, 모든 객체가 자체에 연결되어있어 대칭입니다. P가 Q에 연결되면 Q는 P에 연결되고 이는 전 이적입니다. P가 Q에 연결되고 Q가 R에 연결되면 P는 R에 연결됩니다. 이제 이러한 속성은 매우 직관적입니다. 하지만 명시 적으로 명시하고 알고리즘이 알고리즘을 유지하는지 확인하는 것이 좋습니다. 등가 관계가있을 때 객체와 연결 집합은 연결된 구성 요소라는 하위 집합으로 나뉩니다. 연결된 구성 요소는 상호 연결된 최대 개체 집합입니다. 예를 들어 여기에있는이 작은 예에서는 3 개의 연결된 구성 요소가 있습니다. 하나는 단지 객체 0으로 구성되고, 두 번째 객체는 1, 4 및 5로 구성됩니다. 그리고 세 번째 것은 다른 네 개의 사물들입니다. 그리고이 구성 요소는 그 안에 두 개의 객체가 연결되어 있고 그 객체에 연결된 외부 객체가 없다면 연결된 구성 요소라는 속성을 갖습니다. Google의 알고리즘은 연결된 구성 요소를 유지하고 지식을 사용하여 제시된 쿼리에 효율적으로 응답함으로써 효율성을 높입니다. 좋아, 그래서 작업을 구현하려면, 우리는 쿼리와 노동 조합 명령을 찾아야 해. 그래서 우리는 연결된 구성 요소를 만들 것입니다. find는 두 객체가 같은 컴포넌트에 있는지 확인해야하며 union 명령은 두 객체를 포함하는 컴포넌트를 해당 union으로 대체해야합니다. 예를 들어, 우리가이 컴포넌트들을 가지고 있다면, 우리는 2와 5의 연결을 결합하라는 명령을 얻습니다. 본질적으로, 우리는 두 개의 컴포넌트를 포함하고있는 연결된 컴포넌트 또는 다섯 개의 컴포넌트를 포함하는 연결된 컴포넌트를 병합하여 커다란 연결된 컴포넌트를 얻고 이제는 두 개의 연결된 컴포넌트 만 가지고 있어야합니다. 이 모든 것은 프로그래밍 세계에서 데이터 유형을 지정하는 것으로,이 문제를 해결하기 위해 구현하려는 메소드를 간단하게 지정합니다. 그래서 전형적인 Java 모델에서 우리가 할 일은 UF라는 클래스를 생성하는 것입니다. 두 개의 메소드가 있습니다. 하나는 공용체를 구현하는 메소드이고 다른 하나는 연결된 객체를 구현하는 메소드이며, 하나는 부울을 반환합니다. 생성자는 객체의 수에 따라 데이터 구조를 만들 수 있도록 객체의 수인 SR 단위를 사용합니다. 그래서 우리는 대수를 구축 할 때 객체 수와 거대한 연산 수를 염두에 두어야합니다. 매우 많은 수의 노동 조합과 연결, 운영을 가질 수 있으며 알고리즘은 이러한 조건에서 효율적이어야합니다. 이 과정에서 자주 따르는 관행 중 하나는 우리가 개발하는 데이터 유형을 사용할 클라이언트를 구축하여 문제를 해결하기에 앞서 API 디자인을 확인하는 것입니다. 따라서이 예제에서는 표준 입력에서 정보를 읽는 클라이언트가 있습니다. 첫째, 처리 될 객체의 수를 나타내는 정수. 그리고 일련의 객체 이름 쌍. 그리고 클라이언트가하는 일은 표준 입력에서 정수를 읽고 UF 객체를 생성합니다. 표준 입력이 비어 있지 않으면 입력에서 두 개의 정수를 읽습니다. 연결되지 않으면 연결되어 인쇄됩니다. 그들이 연결되면 무시됩니다. 이것이 바로 우리의 테스트 클라이언트이며, 이는 구현이 우리가 기대하는 바를 수행하는지 확인하는 훌륭한 테스트 클라이언트입니다. 그래서, 그것이 설치입니다. 우리는 코드에 이르기까지 모든 작업을 구현하고자하는 작업을 설명했으며 우리가 제공해야하는 클라이언트 코드를 가지고 있습니다.