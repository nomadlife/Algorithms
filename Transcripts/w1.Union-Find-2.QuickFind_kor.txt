이제 Quick-find라고하는 동적 연결 문제를 해결하기위한 알고리즘을 처음으로 구현하는 방법을 살펴 보겠습니다. 친절한 활동 문제를 해결하기 위해 열망하는 알고리즘입니다. 알고리즘을 지원하기 위해 사용할 데이터 구조는 객체로 인덱싱 된 정수 배열입니다. 해석은 두 객체입니다. P와 Q는 배열의 항목이 동일 할 때만 연결됩니다. 예를 들어, 10 개의 객체를 가진이 예제에서, 7 개의 연결 후 상황을 설명하는 아이디어 배열이 슬라이드 가운데에 그려져 있습니다. 따라서이 시점에서, 0, 5, 6은 모두 같은 연결 요소 인 동일한 배열 항목에 있기 때문에 모두 동일한 연결 구성 요소에 있습니다. 1, 2, 7 모두 엔트리 1이 있습니다. 그리고 3, 4, 8, 9 모두 엔트리 8이 있습니다. 그 표현은 그들이 연결된 것을 보여줍니다. 그리고 이것은 find 연산을 빠르게 구현하는 것을 지원할 것입니다. 우리는 배열 항목을 점검하여 이들이 동일한 지 확인합니다. P와 Q가 같은 ID인지 확인하십시오. 6 명과 1 명은 서로 다른 ID를 가지고 있습니다. 하나는 ID 1, 6은 ID 0입니다. 그들은 동일한 연결 구성 요소에 있지 않습니다. Union은 두 개의 주어진 객체를 포함하는 구성 요소를 병합하기가 더 어렵습니다. ID가 다른 ID와 동일한 모든 항목을 변경해야합니다. 그리고 임의적으로 우리는 P와 같은 것들을 Q와 같은 것으로 바꾸기로 선택합니다. 따라서 우리가 6과 1을 결합한다면, 우리는 엔트리를 0, ​​5, 6으로 변경해야합니다. 모두 같은 연결 구성 요소에 6. 0에서 1까지. 그리고 우리가 볼 수 있듯이, 많은 양의 객체를 가지고있을 때 이것은 약간의 문제입니다. 변경 될 수있는 많은 가치가 있기 때문입니다. 그러나 여전히 구현하기 쉽습니다. 그래서 우리의 출발점이 될 것입니다. 그래서 우리는이 작품이 어떻게 작동하는지에 대한 데모로 시작하겠습니다. 그래서, 처음 엔 각 엔트리가 인덱스와 동일한 ID 배열을 설정했습니다. 그래서 모든 것들은 모든 것이 독립적이라는 것입니다. 그들은 그들 자신의 연결된 구성 요소 안에 있습니다. 자, 우리가 노동 조합 운영을 할 때. 그래서, 4 명은 3 명과 함께 있어야한다고합니다. 그런 다음 ID가 첫 번째 ID와 동일한 두 번째 항목까지 모든 항목을 변경합니다. 따라서이 경우에는 3을 변경하고 4를 연결하면 4를 3으로 변경해야합니다. 그리고 앞으로도 몇 가지 작업을 계속 수행하여 작동 방식에 대한 아이디어를 얻으실 수 있습니다. 이제 3과 8을 연결하여 3과 8을 연결하면 3과 4가 8로 연결되어야합니다. 따라서이 두 항목은 모두 8로 변경되어야합니다. 괜찮아? 자, 이제 6 살과 5 살은 어떨까요? 다시 한번, 우리는 첫 번째 것을 두 번째 것과 일치하도록 변경합니다. 따라서 6과 5를 연결하려면 6을 5로 변경하십시오. 9와 4는 어때? 그래서, 이제 우리는 9와 4를 연결하기 위해 그것을 변경해야합니다. 우리는 9의 항목을 4와 동일하게 변경해야합니다. 이제 우리는 3,4,8,9가 있습니다. 모두 8 개의 항목이 있습니다. 그들은 모두 동일한 연결 구성 요소에 있습니다. 2와 1은 우리가 2201을 변경함으로써 2와 1을 연결한다는 것을 의미합니다. 8과 9는 이미 연결되어 있습니다. 아이디어 배열에는 항목이 동일합니다. 그래서, find라는 연결된 쿼리는 사실이며, 이미 연결되어 있습니다. 그리고 5와 0은 다른 엔트리를 가지고 있습니다. 그들은 연결되지 않았으므로, 우리는 false로 돌아가고,이 경우 연결되지 않습니다. 그리고 우리가 5와 0을 연결하고자한다면. 그런 다음 평소와 같이 5와 6에 해당하는 항목을 0으로 연결합니다. 7과 2, 노동 조합 7과 2. 그것은 쉬운 것입니다. 그리고 노조, 6 명과 1 명은 세 가지 항목이 필요합니다. 모든 0은 1로 변경해야합니다. Quick-find의 빠른 데모입니다. 이제는 구현을위한 코드를 살펴 보겠습니다. 좋아,이 구체적인 데모를 염두에두면이 알고리즘을 코딩하는쪽으로 이동하는 것이 매우 간단합니다. 재미있는 프로그래밍 연습이지만 많은 사람들이 처음으로 잘못 이해하게됩니다. 그래서 생성자부터 시작해 봅시다. 우리는 개인 정수 배열을 가지고 있습니다. ID 배열입니다. 이것이이 구현을 지원할 데이터 구조입니다. 생성자는 배열을 생성 한 다음 각 인덱스 I에 해당하는 값을 I로 설정해야합니다. 이는 간단합니다. 찾기 작업 또는 연결된 작업. 그것은 쉬운 것입니다. 이것은 빠른 찾기 알고리즘입니다. 따라서 두 개의 인수 인 P와 Q를 사용하고 ID 항목이 같은지 여부를 확인한 다음 그 값을 반환합니다. 동등한 경우 true를 반환합니다. 일치하지 않으면 false를 반환합니다. 보다 복잡한 작업 구현은 조합입니다. 그리고 거기에서 첫 번째 인수에 해당하는 ID를 찾은 다음 두 번째 인수에 해당하는 ID를 찾습니다. 그런 다음 전체 배열을 살펴보고 ID가 첫 번째 인수의 ID와 같은 항목을 찾고 두 번째 인수의 ID로 설정합니다. 이것은 매우 간단한 구현입니다. 그리고 많은 사람들이 우리를 잘못 이해할 것이라고 언급했습니다.

우리가 할 수있는 실수는 먼저 P를 찾아내는 것이 아니라 그 값을 P에 두는 것입니다. 그리고 그 의미에 대해 생각할 수 있습니다. 그것은 교활한 버그입니다. 따라서 QuickFind를 잘 구현 했으므로 다음으로 결정할 것은 알고리즘이 얼마나 효율적이고 효율적인지를 결정하는 것이고 우리는이를 수행하는 방법에 대해 자세히 이야기 할 것입니다. 그러나이를 위해 코드가 배열에 액세스해야합니다. 구현을 할 때 보았 듯이 초기화 된 작업과 노동 조합 작업 모두 for-loop와 관련되어 전체 배열을 통과합니다. 따라서 배열 입력을 만진 후 n 시간에 일정한 비례 관계를 유지해야합니다. 작업 찾기가 빠릅니다. 일정한 횟수만큼 배열 항목을 확인하십시오. 그리고 노동 조합 운영이 너무 비싸서 문제가됩니다. 특히 N 개의 객체에 N 개의 union 명령이있는 경우에는 무리가 없습니다. 그들은 연결되어 있든 그렇지 않든 제곱 시간으로 이차 시간을 걸릴 것입니다. 그리고이 과정에서 계속해서 반복 할 테마 중 하나는 이차 시간이 많이 느려지는 것입니다. 그리고 우리는 큰 문제에 대한 이차 시간 알고리즘을 받아 들일 수 없습니다. 그 이유는 그들이 비례하지 않기 때문입니다. 컴퓨터가 점점 더 커지면서 2 차 알고리즘은 실제로 느려집니다. 이제, 내가 의미하는 바를 대략적으로 이야기 해 봅시다. 매우 거친 표준은 현재 사람들이 초당 수십억 개의 연산을 수행 할 수있는 컴퓨터를 가지고 있으며 주 메모리에 수십억 개의 항목이 있다는 것입니다. 즉, 주 메모리에있는 모든 것을 약 1 초 만에 만질 수 있다는 의미입니다. 이 거친 표준이 실제로 50 년 또는 60 년 동안 유지되는 놀라운 사실입니다. 컴퓨터가 커지면 속도는 빨라지고 메모리에있는 모든 것을 만지려면 몇 초가 걸릴 것입니다. 이제 컴퓨터가 단지 수천 단어의 메모리를 가지고 있고 실제로 수십억이나 그 이상을 가지고있는 것이 사실입니다. 그러니 그 컴퓨터가 어떤 컴퓨터인지 이해합시다. 이제 거대한 기억으로 거대한 문제를 해결할 수 있다는 것을 의미합니다. 그래서 우리는 수십억 가지의 대상을 가질 수 있었고 수십억 개의 노동 조합 명령을 수행하기를 희망했습니다. 그리고 그 빠른 찾기 알고리즘의 문제점은 10 ^ 18 번째 연산이 필요하거나 배열 축 또는 메모리를 만지는 것입니다. 그리고 수학을한다면 30 년의 컴퓨터 시간이 필요합니다. 분명히, 오늘날의 컴퓨터에서 이러한 문제를 해결할 실용적이지 않습니다. 그리고 그 이유는 2 차 알고리즘이 기술에 비례하지 않는다는 것입니다. 10 배 빠른 새 컴퓨터가있을 수도 있지만 10 배나 큰 문제를 해결할 수 있습니다. 그리고 그것을 할 때 2 차 알고리즘을 사용합니다. 그것은 10 배나 느려질 것입니다. 이것이 바로 이와 같은 문제를 해결하기위한보다 효율적인 알고리즘을 개발함으로써 회피하려는 상황입니다.